--------------------------------------------------------------------------------------------------
RESOURCE HANDLING
--------------------------------------------------------------------------------------------------

Anyway, firstly we're going to handle only premade torso+legs.

The sprites are going to grow in number, but we'll handle it like this:
Every sprite will be named with the following schema:

torso_[basic, warrior, ninja, ... etc]_[rifle, pistol, barehands]_[shoot, walk]_[1, 2, 3, 4, 5] 	= 30 sprites for every instance
legs_[instances...]_[walk, run]_[1, 2, 3, 4, 5]      												= 10 sprites for every instance

arms_[instances...]_walk_[1, 2]
arms_[instances...]_hit_[1, 2, 3, 4, 5]
arms_[instances...]_hold_[rifle, pistol, barehanded] 												= 2 + 5 + 3 = 10 sprites for every instance

head_[instances...]																					= 1 sprite for every instance

In the end, we're going to tokenize all the filenames and use them to create a nested array to map an item of specified properties to a corresponding texture object.
This in turn will be used to map an item with name "m4a1" to its sprite, for example.

Storing texture files:
Gameplay textures - these will be loaded and available all the time in the gpu; ONE FOLDER FOR ALL OF THEM
Maps textures - another folder for all of them, the game will dynamically determine which files are to be loaded (according to the current map, for example)

--------------------------------------------------------------------------------------------------
OUTFIT SYSTEM
--------------------------------------------------------------------------------------------------

render order:

Legs -> Arms -> Torso -> Head

All of above should have customizable colors.

--------------------------------------------------------------------------------------------------
MAPS AND LOADERS
--------------------------------------------------------------------------------------------------

Lua exports created with Tiled editor will be held in data/maps folder along with all the needed resources.

It is impossible to express all level logic simply in a map editor, so we'll take advantage of "loaders" held in scripts/loaders folder.
These will parse all the object types accordingly, especially unusual objects like enemies or quest objects.

Consider getting rid of "type library" mediator. Although...
it may be used as a helper for defining property sets for the simplest entity objects with no additional logic:
trees, walls and so on. It may even be used for more complicated archetypes if it partially consists of a basic entity object, see: clocks in sensibilia, wayward objects.

The reason for using custom lua type library as a mediator between: [object-specific properties set in tiled]<->[properties overriden by map loader] 
is that Tiled does not support type libraries in itself and it would be hard to create such a complicated parser for [object-specific properties] 
that we can set all possible properties for an entity.


Now the primary difference between a scene and a loader:
A scene encapsulates behaviour that will be common for all scene types, whether are these menus, or arctic maps, or sceneries of dreams.
It merely loads the resources like gameplay sounds + sprites, and resources associated with the map it is going to load;

All of these scenes will need different kind of cameras, players with different properties and so on.
The loader is responsible for initializing these gameplay-specific features, like camera, and setting it to follow the player for example.
If something in the map says so (let it be an initialization script in map properties), the loader should handle it accordingly.


TEXTURE ATLASES!

At first, we will probably have only one atlas with both gameplay and map textures.
As the maps grow in detail, we will create a separate atlas for example for ground art.



--------------------------------------------------------------------------------------------------
NETWORKING
--------------------------------------------------------------------------------------------------

When the packet with a new position arrives to the server, 
it should calculate a force vector (or velocity vector) to be applied to the character so that in the next simulation step it reaches the requested position.










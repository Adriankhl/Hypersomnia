--------------------------------------------------------------------------------------------------
RESOURCE HANDLING
--------------------------------------------------------------------------------------------------

Anyway, firstly we're going to handle only premade torso+legs.

The sprites are going to grow in number, but we'll handle it like this:
Every sprite will be named with the following schema:

torso_[basic, warrior, ninja, ... etc]_[shoot, walk]_[rifle, pistol, barehands, melee]_[1, 2, 3, 4, 5] 	= 40 sprites for every instance
legs_[instances...]_[walk, run]_[1, 2, 3, 4, 5]      												= 10 sprites for every instance

arms_[instances...]_walk_[1, 2]
arms_[instances...]_hit_[1, 2, 3, 4, 5]
arms_[instances...]_hold_[rifle, pistol, barehands, melee] 												= 2 + 5 + 4 = 11 sprites for every instance

head_[instances...]																					= 1 sprite for every instance

In the end, we're going to tokenize all the filenames and use them to create a nested array to map an item of specified properties to a corresponding texture object.
This in turn will be used to map an item with name "m4a1" to its sprite, for example.

Storing texture files:
Gameplay textures - these will be loaded and available all the time in the gpu; ONE FOLDER FOR ALL OF THEM
Maps textures - another folder for all of them, the game will dynamically determine which files are to be loaded (according to the current map, for example)


There will be one animation set per every suitable bodypart (torso, legs) per every weapon type per every outfit.

--------------------------------------------------------------------------------------------------
OUTFIT SYSTEM
--------------------------------------------------------------------------------------------------

render order:

Legs -> Arms -> Torso -> Head

All of above should have customizable colors.

--------------------------------------------------------------------------------------------------
MAPS AND LOADERS
--------------------------------------------------------------------------------------------------

Lua exports created with Tiled editor will be held in data/maps folder along with all the needed resources.

It is impossible to express all level logic simply in a map editor, so we'll take advantage of "loaders" held in scripts/loaders folder.
These will parse all the object types accordingly, especially unusual objects like enemies or quest objects.

Consider getting rid of "type library" mediator. Although...
it may be used as a helper for defining property sets for the simplest entity objects with no additional logic:
trees, walls and so on. It may even be used for more complicated archetypes if it partially consists of a basic entity object, see: clocks in sensibilia, wayward objects.

The reason for using custom lua type library as a mediator between: [object-specific properties set in tiled]<->[properties overriden by map loader] 
is that Tiled does not support type libraries in itself and it would be hard to create such a complicated parser for [object-specific properties] 
that we can set all possible properties for an entity.


Now the primary difference between a scene and a loader:
A scene encapsulates behaviour that will be common for all scene types, whether are these menus, or arctic maps, or sceneries of dreams.
It merely loads the resources like gameplay sounds + sprites, and resources associated with the map it is going to load;

All of these scenes will need different kind of cameras, players with different properties and so on.
The loader is responsible for initializing these gameplay-specific features, like camera, and setting it to follow the player for example.
If something in the map says so (let it be an initialization script in map properties), the loader should handle it accordingly.


TEXTURE ATLASES!

At first, we will probably have only one atlas with both gameplay and map textures.
As the maps grow in detail, we will create a separate atlas for example for ground art.



--------------------------------------------------------------------------------------------------
NETWORKING
--------------------------------------------------------------------------------------------------


Forget about IOCP. We'll just block on recvfrom in a single thread and dispatch all the recv results to the main, single server logic thread.
There's no sense in maintaining several logic threads; it imposes too much synchronization.

If it's about multithreading, simply use it INSIDE main server logic for splitting heavy but simple TASKS in parallel.

About packet composition: forget about bit streams or something like this. We'll be writing data byte-wise.
With bit stream approach you'd gain several bytes at best, as floats/ints will make most of the payload. That's a premature optimization and it's more performant
to operate on bytes.


--------------------------------------------
MIXING LUA WITH C++
--------------------------------------------

ON THE SERVER:
edit:
we can do this like the client does. Only networking-related stuff written in C++. Everything else, including  asynchronous i/o callbacks, is going to be handled in lua. 
Consider one global "master" lua_State eg. for current globals (server settings for example) and commands from developer console.
Then we could have one lua_State per every worker thread.
Then on any i/o callback, globals from "master" lua_State would be copied to the thread-specific lua_State.

Advantages of this approach are as follows:
- faster and easier workflow
- creating NPCs, items and whatnot during server runtime without the need to reboot

Disadvantages:
- a bit worse performance (but we shouldn't worry now; we'll later seek bottlenecks and reimplement them in C++)

OLD approach:
(((( 
All the logic written in C++ for the sake of easy threading and performance. 
Scripting only for server startup: initialization stuff for entities, maps etc. written in lua (we'll use Tiled maps exported to lua by the way). 
Consider scripted AI (but not necessarily).
))))

ON THE CLIENT: Separation of concerns: again - C++ for iocp + networking stuff, eg. my own-rolled reliable udp protocol, all the send/recv and other utility functions.
How is it going to work: C++ will hold two queues: one for outcoming and one for incoming messages.



 (worker iocp thread, mainly transferring and acknowledging messages), 
whereas Lua code will simply interpret all the incoming messages.
There is going to be a queue for incoming messages and outcoming messages, both protected by a critical section that lua code will occassionally step into.


Perhaps all the networking stuff will be written in C++;
Lua will be only used for initialization stuff (not only map loading; also new client initialization etc.) 
and should not be included in realtime logic because it can't be efficiently multithreaded.


When the packet with a new position arrives to the server, 
it should calculate a force vector (or velocity vector) to be applied to the character so that in the next simulation step it reaches the requested position.

Regarding dynamic objects:

Inside client simulation, other characters can not at all collide with dynamic objects - only the player can, so it compensates for round trip time.
Whenever the server detects that a body has left the "sleeping" state, it updates positions for all the players, until they come to sleep again.



The server should simulate physics in some decent intervals, say 60/120 Hz, and there should be another thread that sends all UDP packets with the current game frame at a constant pace.


Firstly, we should create a simple connection over TCP/IP, as it will be definitely easier just to use tcp + iocp than to reimplement a reliable protocol over UDP that acts AS GOOD as TCP.
Anyway it will be of use to gain that knowledge.

THEN AGAIN, I am more biased towards using UDP only. 
We will have a lot less overhead and the volume of our data will be really really low and TCP optimizes for amount of data sent per fixed amount of time, where with UDP we can optimize
for latency.

THIS IS ALSO BECAUSE: HERE, USING TCP FOR CHAT MESSAGES/LEVEL DATA IS A PREMATURE OPTIMIZATION.
I will anyway need a reliable layer on top of UDP for gunshots, since they have to be sent with a higher frequency and that is something I cannot control with TCP.
When it turns out that we need more flow control over level data or reliable commands, we'll use TCP for each of these accordingly. Period.



Then we are going to make use of some simple UDP class that merely makes non-blocking calls to recv and send.
NOPE! We are going to use UDP within IOCP, too. At least we'll have all the multithreading in one place.

What is important for now is to create a suitable workplace that will enable us to work on both the client and the server.

Please, try to grasp one concept at a time.

--------------------------------------------------------------------------------------------------
GAMEPLAY
--------------------------------------------------------------------------------------------------

Feature: scrolling.
Player should be able to instantly zoom in and out by using scroll. 
This will function as a map; it will greatly help in navigation and make the player situationally aware.




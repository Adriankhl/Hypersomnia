--------------------------------------------------------------------------------------------------
RESOURCE HANDLING
--------------------------------------------------------------------------------------------------

Anyway, firstly we're going to handle only premade torso+legs.

The sprites are going to grow in number, but we'll handle it like this:
Every sprite will be named with the following schema:

torso_[basic, warrior, ninja, ... etc]_[shoot, walk]_[rifle, pistol, barehands, melee]_[1, 2, 3, 4, 5] 	= 40 sprites for every instance
legs_[instances...]_[walk, run]_[1, 2, 3, 4, 5]      												= 10 sprites for every instance

arms_[instances...]_walk_[1, 2]
arms_[instances...]_hit_[1, 2, 3, 4, 5]
arms_[instances...]_hold_[rifle, pistol, barehands, melee] 												= 2 + 5 + 4 = 11 sprites for every instance

head_[instances...]																					= 1 sprite for every instance

In the end, we're going to tokenize all the filenames and use them to create a nested array to map an item of specified properties to a corresponding texture object.
This in turn will be used to map an item with name "m4a1" to its sprite, for example.

Storing texture files:
Gameplay textures - these will be loaded and available all the time in the gpu; ONE FOLDER FOR ALL OF THEM
Maps textures - another folder for all of them, the game will dynamically determine which files are to be loaded (according to the current map, for example)


There will be one animation set per every suitable bodypart (torso, legs) per every weapon type per every outfit.

--------------------------------------------------------------------------------------------------
OUTFIT SYSTEM
--------------------------------------------------------------------------------------------------

render order:

Legs -> Arms -> Torso -> Head

All of above should have customizable colors.

--------------------------------------------------------------------------------------------------
MAPS AND LOADERS
--------------------------------------------------------------------------------------------------

Lua exports created with Tiled editor will be held in data/maps folder along with all the needed resources.

It is impossible to express all level logic simply in a map editor, so we'll take advantage of "loaders" held in scripts/loaders folder.
These will parse all the object types accordingly, especially unusual objects like enemies or quest objects.

Consider getting rid of "type library" mediator. Although...
it may be used as a helper for defining property sets for the simplest entity objects with no additional logic:
trees, walls and so on. It may even be used for more complicated archetypes if it partially consists of a basic entity object, see: clocks in sensibilia, wayward objects.

The reason for using custom lua type library as a mediator between: [object-specific properties set in tiled]<->[properties overriden by map loader] 
is that Tiled does not support type libraries in itself and it would be hard to create such a complicated parser for [object-specific properties] 
that we can set all possible properties for an entity.


Now the primary difference between a scene and a loader:
A scene encapsulates behaviour that will be common for all scene types, whether are these menus, or arctic maps, or sceneries of dreams.
It merely loads the resources like gameplay sounds + sprites, and resources associated with the map it is going to load;

All of these scenes will need different kind of cameras, players with different properties and so on.
The loader is responsible for initializing these gameplay-specific features, like camera, and setting it to follow the player for example.
If something in the map says so (let it be an initialization script in map properties), the loader should handle it accordingly.


TEXTURE ATLASES!

At first, we will probably have only one atlas with both gameplay and map textures.
As the maps grow in detail, we will create a separate atlas for example for ground art.



--------------------------------------------------------------------------------------------------
NETWORKING
--------------------------------------------------------------------------------------------------


Forget about IOCP. We'll just block on recvfrom in a single thread and dispatch all the recv results to the main, single server logic thread.
There's no sense in maintaining several logic threads; it imposes too much synchronization.

If it's about multithreading, simply use it INSIDE main server logic for splitting heavy but simple TASKS in parallel.

About packet composition: forget about bit streams or something like this. We'll be writing data byte-wise.
With bit stream approach you'd gain several bytes at best, as floats/ints will make most of the payload. That's a premature optimization and it's more performant
to operate on bytes.

Firstly write a simple chat channel.


RELIABLE TRANSPORT LAYER

About reliable commands:
We'll simply buffer all the incoming messages and only process packets belonging to the first consecutive chain. That's basically how TCP's recv works.

About channels:
We'll have a game_protocol class that will hold both sequenced channel and sequenced acknowledged channel (which provides guaranteed in-order delivery).




We'll use RakNet anyway.
Now about testing - we should create multiple instances of client in the same application for debugging. RakNet will handle this with GUIDs per RakPeerInstance.
We will split screens and render portions of the scene accordingly.


--------------------------------------------
SERVER ARCHITECTURE
--------------------------------------------

We'll need an entity system here so even the on_connection logic is encapsulated in a separate system
client_component is a module that makes a requests for synchronization and receives it


synchronization components will be transmitted on object creation and will only contain some flags like,
whether to synchronize movement+orientation, and they will also hold lag-compensation specific data for given problem domain

for example movementsynchronization component will hold a flag whether to synchronize rotation + position or just position,
and will additionally hold history of past positions for lag compensation which will be used by raycasthit detection system or smthn like that


We will send packets that will contain whole data per-object sequentially;
so if we consider using entity systems, there can only be one networking(or called "synchronization") component.
The component itself will contain an array of modules (movementsynchro, orientationsynchro etc) each of which will have its own update function that writes to a bitstream.

We will have gameplay components and a single synchronization component (both in the same entity system).
This way the gameplay programmer and network programmer will be able to do things in parallel.

But do we really need an ECS architecture for this? Surely, for gameplay, but the synchronization is another beast.

Even where there is 1:1 system-component relationship, ECSes will be useful to handle things like adding/removing objects from global arrays and automatically
assigning them.

When transmitting entities to client, we will simply attach a bitfield saying what synchronization modules are there to read from incoming bitstreams.

We will use message-oriented approach.
This will yield the following advantages:
- when posting an event you only worry about the caller; there are going to be several callee's we don't think about at the moment
this means that when you'd want to post an artificial network packet, you don't have to call all handlers like player movement handler,
but instead all the potentially interested systems process the message for you later.

you'll more likely notice it better as soon as the system's complexity increases, as for now it seems like only the way functions are called is different.

- in C++ we would anyway use this design for several other reasons so its best to structure the code so if we're to port the code to C++ after prototyping, it will be more intuitive to do so



About synchronization:
we'll likely apply a simple division over update types:
- reliable events, like "he's now standing still at pos..", "this got deleted/created"
- streaming, visual unreliable events

thus whole reliable state of the object can be updated regardless of the current streamed visual state (pos/vel);
and the reliable state for movement module will be simply whether the object is sleeping or not.


As soon as we introduce only-proximity updates, the modules will hold a per-client most recently transmitted state, so when the client gets into the proximity of the object again,
we will only send data that has changed since the client last saw the object. 

Then the client_system:add_client won't call "full_state" on synchronization modules, but rather "delta_state" again but just with a pointer to the client as an another argument.

But for the sake of simplicity now, we will only keep one state per module for delta encoding.


Now what if we see an object and then get far away from it, then the object gets destroyed and then we come back to the same place?
We could solve this by making deletion events global to all of those clients who have ever seen the object.


There is a problem regarding objects moving and later standing still.
Whereas a notification about sleeping may arrive after or before the last movement packet and it will be ok,
if a notification about awakening arrives after some post-awakening movement updates, then these packets get discarded and basically we're waiting for potential retransmission of an awakening packet.

we could solve this by acknowledging all unreliable sequenced packets from the client and on server just consider an object as sleeping as soon as an acknowledgement 
that a client has received a vel=0 update arrives.

The client could send these acknowledgements only when it receives an update containing an object with zero velocity.


The client should also detect when an object goes outside its view (proximity) and further hide it until it gets a message from the server about its new position/velocity.

--------------------------------------------
MIXING LUA WITH C++
--------------------------------------------

ON THE SERVER:
edit:
we can do this like the client does. Only networking-related stuff written in C++. Everything else, including  asynchronous i/o callbacks, is going to be handled in lua. 
Consider one global "master" lua_State eg. for current globals (server settings for example) and commands from developer console.
Then we could have one lua_State per every worker thread.
Then on any i/o callback, globals from "master" lua_State would be copied to the thread-specific lua_State.

Advantages of this approach are as follows:
- faster and easier workflow
- creating NPCs, items and whatnot during server runtime without the need to reboot

Disadvantages:
- a bit worse performance (but we shouldn't worry now; we'll later seek bottlenecks and reimplement them in C++)

OLD approach:
(((( 
All the logic written in C++ for the sake of easy threading and performance. 
Scripting only for server startup: initialization stuff for entities, maps etc. written in lua (we'll use Tiled maps exported to lua by the way). 
Consider scripted AI (but not necessarily).
))))

ON THE CLIENT: Separation of concerns: again - C++ for iocp + networking stuff, eg. my own-rolled reliable udp protocol, all the send/recv and other utility functions.
How is it going to work: C++ will hold two queues: one for outcoming and one for incoming messages.



 (worker iocp thread, mainly transferring and acknowledging messages), 
whereas Lua code will simply interpret all the incoming messages.
There is going to be a queue for incoming messages and outcoming messages, both protected by a critical section that lua code will occassionally step into.


Perhaps all the networking stuff will be written in C++;
Lua will be only used for initialization stuff (not only map loading; also new client initialization etc.) 
and should not be included in realtime logic because it can't be efficiently multithreaded.


When the packet with a new position arrives to the server, 
it should calculate a force vector (or velocity vector) to be applied to the character so that in the next simulation step it reaches the requested position.

Regarding dynamic objects:

Inside client simulation, other characters can not at all collide with dynamic objects - only the player can, so it compensates for round trip time.
Whenever the server detects that a body has left the "sleeping" state, it updates positions for all the players, until they come to sleep again.



The server should simulate physics in some decent intervals, say 60/120 Hz, and there should be another thread that sends all UDP packets with the current game frame at a constant pace.


Firstly, we should create a simple connection over TCP/IP, as it will be definitely easier just to use tcp + iocp than to reimplement a reliable protocol over UDP that acts AS GOOD as TCP.
Anyway it will be of use to gain that knowledge.

THEN AGAIN, I am more biased towards using UDP only. 
We will have a lot less overhead and the volume of our data will be really really low and TCP optimizes for amount of data sent per fixed amount of time, where with UDP we can optimize
for latency.

THIS IS ALSO BECAUSE: HERE, USING TCP FOR CHAT MESSAGES/LEVEL DATA IS A PREMATURE OPTIMIZATION.
I will anyway need a reliable layer on top of UDP for gunshots, since they have to be sent with a higher frequency and that is something I cannot control with TCP.
When it turns out that we need more flow control over level data or reliable commands, we'll use TCP for each of these accordingly. Period.



Then we are going to make use of some simple UDP class that merely makes non-blocking calls to recv and send.
NOPE! We are going to use UDP within IOCP, too. At least we'll have all the multithreading in one place.

What is important for now is to create a suitable workplace that will enable us to work on both the client and the server.

Please, try to grasp one concept at a time.

--------------------------------------------------------------------------------------------------
GAMEPLAY
--------------------------------------------------------------------------------------------------

Feature: scrolling.
Player should be able to instantly zoom in and out by using scroll. 
This will function as a map; it will greatly help in navigation and make the player situationally aware.




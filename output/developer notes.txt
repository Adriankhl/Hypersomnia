--------------------------------------------------------------------------------------------------
RESOURCE HANDLING
--------------------------------------------------------------------------------------------------

Anyway, firstly we're going to handle only premade torso+legs.

The sprites are going to grow in number, but we'll handle it like this:
Every sprite will be named with the following schema:

torso_[basic, warrior, ninja, ... etc]_[shoot, walk]_[rifle, pistol, barehands, melee]_[1, 2, 3, 4, 5] 	= 40 sprites for every instance
legs_[instances...]_[walk, run]_[1, 2, 3, 4, 5]      												= 10 sprites for every instance

arms_[instances...]_walk_[1, 2]
arms_[instances...]_hit_[1, 2, 3, 4, 5]
arms_[instances...]_hold_[rifle, pistol, barehands, melee] 												= 2 + 5 + 4 = 11 sprites for every instance

head_[instances...]																					= 1 sprite for every instance

In the end, we're going to tokenize all the filenames and use them to create a nested array to map an item of specified properties to a corresponding texture object.
This in turn will be used to map an item with name "m4a1" to its sprite, for example.

Storing texture files:
Gameplay textures - these will be loaded and available all the time in the gpu; ONE FOLDER FOR ALL OF THEM
Maps textures - another folder for all of them, the game will dynamically determine which files are to be loaded (according to the current map, for example)


There will be one animation set per every suitable bodypart (torso, legs) per every weapon type per every outfit.

--------------------------------------------------------------------------------------------------
OUTFIT SYSTEM
--------------------------------------------------------------------------------------------------

render order:

Legs -> Arms -> Torso -> Head

All of above should have customizable colors.

--------------------------------------------------------------------------------------------------
MAPS AND LOADERS
--------------------------------------------------------------------------------------------------

Lua exports created with Tiled editor will be held in data/maps folder along with all the needed resources.

It is impossible to express all level logic simply in a map editor, so we'll take advantage of "loaders" held in scripts/loaders folder.
These will parse all the object types accordingly, especially unusual objects like enemies or quest objects.

Consider getting rid of "type library" mediator. Although...
it may be used as a helper for defining property sets for the simplest entity objects with no additional logic:
trees, walls and so on. It may even be used for more complicated archetypes if it partially consists of a basic entity object, see: clocks in sensibilia, wayward objects.

The reason for using custom lua type library as a mediator between: [object-specific properties set in tiled]<->[properties overriden by map loader] 
is that Tiled does not support type libraries in itself and it would be hard to create such a complicated parser for [object-specific properties] 
that we can set all possible properties for an entity.


Now the primary difference between a scene and a loader:
A scene encapsulates behaviour that will be common for all scene types, whether are these menus, or arctic maps, or sceneries of dreams.
It merely loads the resources like gameplay sounds + sprites, and resources associated with the map it is going to load;

All of these scenes will need different kind of cameras, players with different properties and so on.
The loader is responsible for initializing these gameplay-specific features, like camera, and setting it to follow the player for example.
If something in the map says so (let it be an initialization script in map properties), the loader should handle it accordingly.


TEXTURE ATLASES!

At first, we will probably have only one atlas with both gameplay and map textures.
As the maps grow in detail, we will create a separate atlas for example for ground art.



--------------------------------------------------------------------------------------------------
NETWORKING
--------------------------------------------------------------------------------------------------


Forget about IOCP. We'll just block on recvfrom in a single thread and dispatch all the recv results to the main, single server logic thread.
There's no sense in maintaining several logic threads; it imposes too much synchronization.

If it's about multithreading, simply use it INSIDE main server logic for splitting heavy but simple TASKS in parallel.

About packet composition: forget about bit streams or something like this. We'll be writing data byte-wise.
With bit stream approach you'd gain several bytes at best, as floats/ints will make most of the payload. That's a premature optimization and it's more performant
to operate on bytes.

Firstly write a simple chat channel.


RELIABLE TRANSPORT LAYER

About reliable commands:
We'll simply buffer all the incoming messages and only process packets belonging to the first consecutive chain. That's basically how TCP's recv works.

About channels:
We'll have a game_protocol class that will hold both sequenced channel and sequenced acknowledged channel (which provides guaranteed in-order delivery).




We'll use RakNet anyway.
Now about testing - we should create multiple instances of client in the same application for debugging. RakNet will handle this with GUIDs per RakPeerInstance.
We will split screens and render portions of the scene accordingly.


--------------------------------------------
SERVER ARCHITECTURE
--------------------------------------------

We'll need an entity system here so even the on_connection logic is encapsulated in a separate system
client_component is a module that makes a requests for synchronization and receives it


synchronization components will be transmitted on object creation and will only contain some flags like,
whether to synchronize movement+orientation, and they will also hold lag-compensation specific data for given problem domain

for example movementsynchronization component will hold a flag whether to synchronize rotation + position or just position,
and will additionally hold history of past positions for lag compensation which will be used by raycasthit detection system or smthn like that


We will send packets that will contain whole data per-object sequentially;
so if we consider using entity systems, there can only be one networking(or called "synchronization") component.
The component itself will contain an array of modules (movementsynchro, orientationsynchro etc) each of which will have its own update function that writes to a bitstream.

We will have gameplay components and a single synchronization component (both in the same entity system).
This way the gameplay programmer and network programmer will be able to do things in parallel.

But do we really need an ECS architecture for this? Surely, for gameplay, but the synchronization is another beast.

Even where there is 1:1 system-component relationship, ECSes will be useful to handle things like adding/removing objects from global arrays and automatically
assigning them.

When transmitting entities to client, we will simply attach a bitfield saying what synchronization modules are there to read from incoming bitstreams.

We will use message-oriented approach.
This will yield the following advantages:
- when posting an event you only worry about the caller; there are going to be several callee's we don't think about at the moment
this means that when you'd want to post an artificial network packet, you don't have to call all handlers like player movement handler,
but instead all the potentially interested systems process the message for you later.

you'll more likely notice it better as soon as the system's complexity increases, as for now it seems like only the way functions are called is different.

- in C++ we would anyway use this design for several other reasons so its best to structure the code so if we're to port the code to C++ after prototyping, it will be more intuitive to do so



About synchronization:
we'll likely apply a simple division over update types:
- reliable events, like "he's now standing still at pos..", "this got deleted/created"
- streaming, visual unreliable events

thus whole reliable state of the object can be updated regardless of the current streamed visual state (pos/vel);
and the reliable state for movement module will be simply whether the object is sleeping or not.


As soon as we introduce only-proximity updates, the modules will hold a per-client most recently transmitted state, so when the client gets into the proximity of the object again,
we will only send data that has changed since the client last saw the object. 

Then the client_system:add_client won't call "full_state" on synchronization modules, but rather "delta_state" again but just with a pointer to the client as an another argument.

But for the sake of simplicity now, we will only keep one state per module for delta encoding.


Now what if we see an object and then get far away from it, then the object gets destroyed and then we come back to the same place?
We could solve this by making deletion events global to all of those clients who have ever seen the object.


There is a problem regarding objects moving and later standing still.
Whereas a notification about sleeping may arrive after or before the last movement packet and it will be ok,
if a notification about awakening arrives after some post-awakening movement updates, then these packets get discarded and basically we're waiting for potential retransmission of an awakening packet.

we could solve this by acknowledging all unreliable sequenced packets from the client and on server just consider an object as sleeping as soon as an acknowledgement 
that a client has received a vel=0 update arrives.

The client could send these acknowledgements only when it receives an update containing an object with zero velocity.

Another problem arises when a client gets into proximity of an object and first gets its zero-velocity update, succesfully acknowledges it but only then does it get its NEW_OBJECTS message.
This will be solved by introducing another flag per client called "ack_received" which is set to true on every acknowledgement and set to false on every new state sent.


The client should also detect when an object goes outside its view (proximity) and further hide it until it gets a message from the server about its new position/velocity.
There's another problem when this object is standing still - since the client is not receiving updates about it, it also won't get any update once it gets out and enters its proximity.
(but the client will hide it)

This may be solved by server setting zero-velocity-acked state to false when an object enters the client's proximity.


Perhaps we could use only unreliable sequenced channel even for object states.
This way we'd have more control over how many packets are sent whereas using built-in raknet's reliable layer you don't know.

Now we could replace the acked/updated flags in remote_states and just have a single "acked" flag.


 But perhaps it's just a premature optimization.

A thing to note is that the vast majority of our network traffic will be streamed data that can't be delta compressed in any way (positions, velocities, orientations)
and the rest will be one-shot events (shooting, dropped weapons, weapons picked up, caused damage)
the actual state changes like changing outfits will happen so rarely that there's no point in introducing delta compression for them.
 
A way to go would be to think about actual use-cases; think about things we want to synchronize and think whether using delta's will help them.
 
 
Another thing to note is that if snapshot based unreliable sequenced updates are only to lower the bandwidth we can throw it right away.

Consider introducing functionality like NetChannel without delta snapshots; that may very well be enough for our needs.
client component could hold an array of reliable events which then would be added to the outgoing bitstream.
 
Each incoming reliable message will have an opportunity to invalidate existing reliable messages in case it is "more recent" than the other.

The client should also have its own instance of NetChannel since it will also send reliable messages.




The only places where clients and server synchronize object states are classes from sync_modules. Note that we may also want to synchronize appearance of objects,
and so there should be "appearance_module" that handles things like outfits or just simply environmental object textures.

For now just stick to basic_player + remote_player classes in the client, then experiment with modules.

It might be necessary for the server to send a message every time an object gets out of player's proximity.



Consider "parties" or anything where an object's state may differ across the players.
Example:

For every member in the party, serwer transmits each other's crosshairs positions (8 bytes), not only player orientations (2 bytes if we just send angles 1-65536).
If you don't belong to any party, you can only ever see other players' orientations.

So it becomes obvious we don't want to waste these 2 bytes if we either way have to send 8.

The solution to this might be introducing state groups and assigning clients to them.
Whenever we send an object state for the client, we check to what state group it belongs for a given client.

It's worth noting that a client may belong to many state groups (friends, party, guild),
but an object belongs to only one state group for a given client.


Let us simplify the above concept:
Let the client simply hold a table that maps an existing object id to its client-specific module set.

For a scenario where we wanted to synchronize an entity with only one player,
we can create an entity with NO synchronization modules and make synchronization system assume that 0 modules are not worth for even transmitting a new ID.

Or just make a dedicated client-specific entity table for this exact scenario, then just concatenate this table with table returned by function getting entities in proximity.

When removing an alternative module set, just set remote_states[id] to nil so it updates again.




There's a problem with reliable+unreliable transmission.
Let us maintain following data types:

(STATE_UPDATE)(STREAM_UPDATE) (INPUT_SNAPSHOT, CROSSHAIR_SNAPSHOT etc.)
[RELIABLE BUF][UNRELIABLE BUF][ONCE BUF]

ONCE BUF should not get dropped even when we failed to match reliable data.
UNRELIABLE BUF should only be dropped if there is a state update changing the stream data layout, what will be included in the message's signature.

--------------------------------------------
TRANSFERRING OBJECT STATE
--------------------------------------------

if the entity was not yet transmitted to us, then there is an archetype identifier to read
spawn the entity according to the given archetype and add synchronization component

we may consider just adding an "appearance" module which handles things like outfits
or whether the entity has legs underneath.

for now just spawn a remote player

for the moment, spawn an entity with only synchronization component attached - 
if the looping logic decides, it may later add any component the entity needs deducing from module set.

how about separating concerns - synchronization system (or rather module receiving system) only receives and alters DATA
inside these objects.

what if on the client, sync objects were just another components? bad idea, that doesn't solve anything

on the server - modules are actually the right thing to do - we don't need to duplicate variables;
the modules themselves can get them from parent entity
we might need to duplicate them for the sake of comparision if we introduce delta;
or we can simply have an update flag for each module to upload whole module again.

on the client modules can simply modify their parent entities in place whenever new data arrives.
then the modules themselves may impose a particular component's existence, for example health or outfit.


the problem we're seeing here is that the whole entity and its components are to be determined based upon the data 
that may arrive within the modules themselves - 
if modules call their own writing logic from input data (eg. velocity setting for box2d bodies),
then we can't call them when the entity is newly created;
on the other side, existence of some game components may depend on either module existence or its particular setting;
for example "has_legs" in appearance_sync module induces creation of another cpp entity.

we could make it like this: let the synchronization system worry only about receiving/altering data for the modules.
the modules would save everything that is received inside appropriate variables then used in an "update" function,
called only AFTER entity creation.

the asymmetry comes from the fact that on the server it is the developer that creates whole entity and its modules;
and there, game components and modules don't even have to match,
whereas the client has to deduce how to represent these modules with game components.


--------------------------------------------
MIXING LUA WITH C++
--------------------------------------------

ON THE SERVER:
edit:
we can do this like the client does. Only networking-related stuff written in C++. Everything else, including  asynchronous i/o callbacks, is going to be handled in lua. 
Consider one global "master" lua_State eg. for current globals (server settings for example) and commands from developer console.
Then we could have one lua_State per every worker thread.
Then on any i/o callback, globals from "master" lua_State would be copied to the thread-specific lua_State.

Advantages of this approach are as follows:
- faster and easier workflow
- creating NPCs, items and whatnot during server runtime without the need to reboot

Disadvantages:
- a bit worse performance (but we shouldn't worry now; we'll later seek bottlenecks and reimplement them in C++)

OLD approach:
(((( 
All the logic written in C++ for the sake of easy threading and performance. 
Scripting only for server startup: initialization stuff for entities, maps etc. written in lua (we'll use Tiled maps exported to lua by the way). 
Consider scripted AI (but not necessarily).
))))

ON THE CLIENT: Separation of concerns: again - C++ for iocp + networking stuff, eg. my own-rolled reliable udp protocol, all the send/recv and other utility functions.
How is it going to work: C++ will hold two queues: one for outcoming and one for incoming messages.



 (worker iocp thread, mainly transferring and acknowledging messages), 
whereas Lua code will simply interpret all the incoming messages.
There is going to be a queue for incoming messages and outcoming messages, both protected by a critical section that lua code will occassionally step into.


Perhaps all the networking stuff will be written in C++;
Lua will be only used for initialization stuff (not only map loading; also new client initialization etc.) 
and should not be included in realtime logic because it can't be efficiently multithreaded.


When the packet with a new position arrives to the server, 
it should calculate a force vector (or velocity vector) to be applied to the character so that in the next simulation step it reaches the requested position.

Regarding dynamic objects:

Inside client simulation, other characters can not at all collide with dynamic objects - only the player can, so it compensates for round trip time.
Whenever the server detects that a body has left the "sleeping" state, it updates positions for all the players, until they come to sleep again.



The server should simulate physics in some decent intervals, say 60/120 Hz, and there should be another thread that sends all UDP packets with the current game frame at a constant pace.


Firstly, we should create a simple connection over TCP/IP, as it will be definitely easier just to use tcp + iocp than to reimplement a reliable protocol over UDP that acts AS GOOD as TCP.
Anyway it will be of use to gain that knowledge.

THEN AGAIN, I am more biased towards using UDP only. 
We will have a lot less overhead and the volume of our data will be really really low and TCP optimizes for amount of data sent per fixed amount of time, where with UDP we can optimize
for latency.

THIS IS ALSO BECAUSE: HERE, USING TCP FOR CHAT MESSAGES/LEVEL DATA IS A PREMATURE OPTIMIZATION.
I will anyway need a reliable layer on top of UDP for gunshots, since they have to be sent with a higher frequency and that is something I cannot control with TCP.
When it turns out that we need more flow control over level data or reliable commands, we'll use TCP for each of these accordingly. Period.



Then we are going to make use of some simple UDP class that merely makes non-blocking calls to recv and send.
NOPE! We are going to use UDP within IOCP, too. At least we'll have all the multithreading in one place.

What is important for now is to create a suitable workplace that will enable us to work on both the client and the server.

Please, try to grasp one concept at a time.

--------------------------------------------------------------------------------------------------
GAMEPLAY
--------------------------------------------------------------------------------------------------

Feature: scrolling.
Player should be able to instantly zoom in and out by using scroll. 
This will function as a map; it will greatly help in navigation and make the player situationally aware.


--------------------------------------------
BULLETS
--------------------------------------------

Implement the penetration as follows: assign an initial damage to the bullet, then
on BeginContact/EndContact play particle effects, and on every PreSolve disable the contact and decrease the damage by some arbitrary, density value.
If the bullet's damage becomes less than zero, delete the bullet.


About server-client synchronization:
Assuming the environment is static, things are very simple. 
The server simply broadcasts the message that the bullet was fired. 
If the bullet lands on a player or another interactive object - simply if it causes an important even to happen (death, for example) - broadcast this fact.
If it hits the wall, we don't care about broadcasting this information since if the environment is static the clients will simulate things the same way.

Things become problematic when we consider dynamic objects - the question arises, who decides about the lifetime of the bullet on the client?
If the client, it is very responsive, we have less bandwidth, but we may falsely simulate a hit against a moving crate, while the bullet actually just flew past it and actually hit the player, for example.
If the server, the hits become less responsive and the bandwidth is doubled, but the hits are always correctly shown only where they occur.

Or, a mix of both: how about sending info only when the bullet hits a dynamic object, and on the client never check against collisions with dynamic objects?
+ still responsive against static terrain;
+ it's better to falsely show a bullet passing through the client-driven character than a false hit against a crate standing in front of us when the bullet actually hit us;
- a little more bandwidth; it's far from being doubled, though.

For the client-driven bullets, do the opposite - check collisions with dynamic objects and only ever receive events caused by the bullet.

Summarizing:

Client-side:
- local bullet hits a static object
- local bullet hits a dynamic object
- remote bullet hits a static object

Client gets info about events in which:
- remote bullet hits a dynamic object
- local bullet makes an event (hits the player)
- remote bullet makes an event (hits the player)


What if we do the hit-detection client-side?
Now if we send a "I hit that player!" message to the server, the server goes back in time resimulates bullet+static environment and only checks whether such a bullet landed on such a player.

We will need to reliably measure the lag between the server and the client to properly advance the bullet forward in time on the server;
without the possibility of cheating.


Note that when receiving "new_bullet" notification, we may want to move it forward in time on the client, by the amount of lag.

With every update, 

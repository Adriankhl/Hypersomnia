--------------------------------------------------------------------------------------------------
RESOURCE HANDLING
--------------------------------------------------------------------------------------------------

Anyway, firstly we're going to handle only premade torso+legs.

The sprites are going to grow in number, but we'll handle it like this:
Every sprite will be named with the following schema:

torso_[basic, warrior, ninja, ... etc]_[shoot, walk]_[rifle, pistol, barehands, melee]_[1, 2, 3, 4, 5] 	= 40 sprites for every instance
legs_[instances...]_[walk, run]_[1, 2, 3, 4, 5]      												= 10 sprites for every instance

arms_[instances...]_walk_[1, 2]
arms_[instances...]_hit_[1, 2, 3, 4, 5]
arms_[instances...]_hold_[rifle, pistol, barehands, melee] 												= 2 + 5 + 4 = 11 sprites for every instance

head_[instances...]																					= 1 sprite for every instance

In the end, we're going to tokenize all the filenames and use them to create a nested array to map an item of specified properties to a corresponding texture object.
This in turn will be used to map an item with name "m4a1" to its sprite, for example.

Storing texture files:
Gameplay textures - these will be loaded and available all the time in the gpu; ONE FOLDER FOR ALL OF THEM
Maps textures - another folder for all of them, the game will dynamically determine which files are to be loaded (according to the current map, for example)


There will be one animation set per every suitable bodypart (torso, legs) per every weapon type per every outfit.

--------------------------------------------------------------------------------------------------
OUTFIT SYSTEM
--------------------------------------------------------------------------------------------------

render order:

Legs -> Arms -> Torso -> Head

All of above should have customizable colors.

--------------------------------------------------------------------------------------------------
MAPS AND LOADERS
--------------------------------------------------------------------------------------------------

Lua exports created with Tiled editor will be held in data/maps folder along with all the needed resources.

It is impossible to express all level logic simply in a map editor, so we'll take advantage of "loaders" held in scripts/loaders folder.
These will parse all the object types accordingly, especially unusual objects like enemies or quest objects.

Consider getting rid of "type library" mediator. Although...
it may be used as a helper for defining property sets for the simplest entity objects with no additional logic:
trees, walls and so on. It may even be used for more complicated archetypes if it partially consists of a basic entity object, see: clocks in sensibilia, wayward objects.

The reason for using custom lua type library as a mediator between: [object-specific properties set in tiled]<->[properties overriden by map loader] 
is that Tiled does not support type libraries in itself and it would be hard to create such a complicated parser for [object-specific properties] 
that we can set all possible properties for an entity.


Now the primary difference between a scene and a loader:
A scene encapsulates behaviour that will be common for all scene types, whether are these menus, or arctic maps, or sceneries of dreams.
It merely loads the resources like gameplay sounds + sprites, and resources associated with the map it is going to load;

All of these scenes will need different kind of cameras, players with different properties and so on.
The loader is responsible for initializing these gameplay-specific features, like camera, and setting it to follow the player for example.
If something in the map says so (let it be an initialization script in map properties), the loader should handle it accordingly.


TEXTURE ATLASES!

At first, we will probably have only one atlas with both gameplay and map textures.
As the maps grow in detail, we will create a separate atlas for example for ground art.



--------------------------------------------------------------------------------------------------
NETWORKING
--------------------------------------------------------------------------------------------------


Forget about IOCP. We'll just block on recvfrom in a single thread and dispatch all the recv results to the main, single server logic thread.
There's no sense in maintaining several logic threads; it imposes too much synchronization.

If it's about multithreading, simply use it INSIDE main server logic for splitting heavy but simple TASKS in parallel.

About packet composition: forget about bit streams or something like this. We'll be writing data byte-wise.
With bit stream approach you'd gain several bytes at best, as floats/ints will make most of the payload. That's a premature optimization and it's more performant
to operate on bytes.

Firstly write a simple chat channel.


RELIABLE TRANSPORT LAYER

About reliable commands:
We'll simply buffer all the incoming messages and only process packets belonging to the first consecutive chain. That's basically how TCP's recv works.

About channels:
We'll have a game_protocol class that will hold both sequenced channel and sequenced acknowledged channel (which provides guaranteed in-order delivery).




We'll use RakNet anyway.
Now about testing - we should create multiple instances of client in the same application for debugging. RakNet will handle this with GUIDs per RakPeerInstance.
We will split screens and render portions of the scene accordingly.


--------------------------------------------
SERVER ARCHITECTURE
--------------------------------------------

We'll need an entity system here so even the on_connection logic is encapsulated in a separate system
client_component is a module that makes a requests for synchronization and receives it


synchronization components will be transmitted on object creation and will only contain some flags like,
whether to synchronize movement+orientation, and they will also hold lag-compensation specific data for given problem domain

for example movementsynchronization component will hold a flag whether to synchronize rotation + position or just position,
and will additionally hold history of past positions for lag compensation which will be used by raycasthit detection system or smthn like that


We will send packets that will contain whole data per-object sequentially;
so if we consider using entity systems, there can only be one networking(or called "synchronization") component.
The component itself will contain an array of modules (movementsynchro, orientationsynchro etc) each of which will have its own update function that writes to a bitstream.

We will have gameplay components and a single synchronization component (both in the same entity system).
This way the gameplay programmer and network programmer will be able to do things in parallel.

But do we really need an ECS architecture for this? Surely, for gameplay, but the synchronization is another beast.

Even where there is 1:1 system-component relationship, ECSes will be useful to handle things like adding/removing objects from global arrays and automatically
assigning them.

When transmitting entities to client, we will simply attach a bitfield saying what synchronization modules are there to read from incoming bitstreams.

We will use message-oriented approach.
This will yield the following advantages:
- when posting an event you only worry about the caller; there are going to be several callee's we don't think about at the moment
this means that when you'd want to post an artificial network packet, you don't have to call all handlers like player movement handler,
but instead all the potentially interested systems process the message for you later.

you'll more likely notice it better as soon as the system's complexity increases, as for now it seems like only the way functions are called is different.

- in C++ we would anyway use this design for several other reasons so its best to structure the code so if we're to port the code to C++ after prototyping, it will be more intuitive to do so



About synchronization:
we'll likely apply a simple division over update types:
- reliable events, like "he's now standing still at pos..", "this got deleted/created"
- streaming, visual unreliable events

thus whole reliable state of the object can be updated regardless of the current streamed visual state (pos/vel);
and the reliable state for movement module will be simply whether the object is sleeping or not.


As soon as we introduce only-proximity updates, the modules will hold a per-client most recently transmitted state, so when the client gets into the proximity of the object again,
we will only send data that has changed since the client last saw the object. 

Then the client_system:add_client won't call "full_state" on synchronization modules, but rather "delta_state" again but just with a pointer to the client as an another argument.

But for the sake of simplicity now, we will only keep one state per module for delta encoding.


Now what if we see an object and then get far away from it, then the object gets destroyed and then we come back to the same place?
We could solve this by making deletion events global to all of those clients who have ever seen the object.


There is a problem regarding objects moving and later standing still.
Whereas a notification about sleeping may arrive after or before the last movement packet and it will be ok,
if a notification about awakening arrives after some post-awakening movement updates, then these packets get discarded and basically we're waiting for potential retransmission of an awakening packet.

we could solve this by acknowledging all unreliable sequenced packets from the client and on server just consider an object as sleeping as soon as an acknowledgement 
that a client has received a vel=0 update arrives.

The client could send these acknowledgements only when it receives an update containing an object with zero velocity.

Another problem arises when a client gets into proximity of an object and first gets its zero-velocity update, succesfully acknowledges it but only then does it get its NEW_OBJECTS message.
This will be solved by introducing another flag per client called "ack_received" which is set to true on every acknowledgement and set to false on every new state sent.


The client should also detect when an object goes outside its view (proximity) and further hide it until it gets a message from the server about its new position/velocity.
There's another problem when this object is standing still - since the client is not receiving updates about it, it also won't get any update once it gets out and enters its proximity.
(but the client will hide it)

This may be solved by server setting zero-velocity-acked state to false when an object enters the client's proximity.


Perhaps we could use only unreliable sequenced channel even for object states.
This way we'd have more control over how many packets are sent whereas using built-in raknet's reliable layer you don't know.

Now we could replace the acked/updated flags in remote_states and just have a single "acked" flag.


 But perhaps it's just a premature optimization.

A thing to note is that the vast majority of our network traffic will be streamed data that can't be delta compressed in any way (positions, velocities, orientations)
and the rest will be one-shot events (shooting, dropped weapons, weapons picked up, caused damage)
the actual state changes like changing outfits will happen so rarely that there's no point in introducing delta compression for them.
 
A way to go would be to think about actual use-cases; think about things we want to synchronize and think whether using delta's will help them.
 
 
Another thing to note is that if snapshot based unreliable sequenced updates are only to lower the bandwidth we can throw it right away.

Consider introducing functionality like NetChannel without delta snapshots; that may very well be enough for our needs.
client component could hold an array of reliable events which then would be added to the outgoing bitstream.
 
Each incoming reliable message will have an opportunity to invalidate existing reliable messages in case it is "more recent" than the other.

The client should also have its own instance of NetChannel since it will also send reliable messages.




The only places where clients and server synchronize object states are classes from sync_modules. Note that we may also want to synchronize appearance of objects,
and so there should be "appearance_module" that handles things like outfits or just simply environmental object textures.

For now just stick to basic_player + remote_player classes in the client, then experiment with modules.

It might be necessary for the server to send a message every time an object gets out of player's proximity.



Consider "parties" or anything where an object's state may differ across the players.
Example:

For every member in the party, serwer transmits each other's crosshairs positions (8 bytes), not only player orientations (2 bytes if we just send angles 1-65536).
If you don't belong to any party, you can only ever see other players' orientations.

So it becomes obvious we don't want to waste these 2 bytes if we either way have to send 8.

The solution to this might be introducing state groups and assigning clients to them.
Whenever we send an object state for the client, we check to what state group it belongs for a given client.

It's worth noting that a client may belong to many state groups (friends, party, guild),
but an object belongs to only one state group for a given client.


Let us simplify the above concept:
Let the client simply hold a table that maps an existing object id to its client-specific module set.

For a scenario where we wanted to synchronize an entity with only one player,
we can create an entity with NO synchronization modules and make synchronization system assume that 0 modules are not worth for even transmitting a new ID.

Or just make a dedicated client-specific entity table for this exact scenario, then just concatenate this table with table returned by function getting entities in proximity.

When removing an alternative module set, just set remote_states[id] to nil so it updates again.




There's a problem with reliable+unreliable transmission.
Let us maintain following data types:

(STATE_UPDATE)(STREAM_UPDATE) (INPUT_SNAPSHOT, CROSSHAIR_SNAPSHOT etc.)
[RELIABLE BUF][UNRELIABLE BUF][ONCE BUF]

ONCE BUF should not get dropped even when we failed to match reliable data.
UNRELIABLE BUF should only be dropped if there is a state update changing the stream data layout, what will be included in the message's signature.

--------------------------------------------
TRANSFERRING OBJECT STATE
--------------------------------------------

if the entity was not yet transmitted to us, then there is an archetype identifier to read
spawn the entity according to the given archetype and add synchronization component

we may consider just adding an "appearance" module which handles things like outfits
or whether the entity has legs underneath.

for now just spawn a remote player

for the moment, spawn an entity with only synchronization component attached - 
if the looping logic decides, it may later add any component the entity needs deducing from module set.

how about separating concerns - synchronization system (or rather module receiving system) only receives and alters DATA
inside these objects.

what if on the client, sync objects were just another components? bad idea, that doesn't solve anything

on the server - modules are actually the right thing to do - we don't need to duplicate variables;
the modules themselves can get them from parent entity
we might need to duplicate them for the sake of comparision if we introduce delta;
or we can simply have an update flag for each module to upload whole module again.

on the client modules can simply modify their parent entities in place whenever new data arrives.
then the modules themselves may impose a particular component's existence, for example health or outfit.


the problem we're seeing here is that the whole entity and its components are to be determined based upon the data 
that may arrive within the modules themselves - 
if modules call their own writing logic from input data (eg. velocity setting for box2d bodies),
then we can't call them when the entity is newly created;
on the other side, existence of some game components may depend on either module existence or its particular setting;
for example "has_legs" in appearance_sync module induces creation of another cpp entity.

we could make it like this: let the synchronization system worry only about receiving/altering data for the modules.
the modules would save everything that is received inside appropriate variables then used in an "update" function,
called only AFTER entity creation.

the asymmetry comes from the fact that on the server it is the developer that creates whole entity and its modules;
and there, game components and modules don't even have to match,
whereas the client has to deduce how to represent these modules with game components.


--------------------------------------------
MIXING LUA WITH C++
--------------------------------------------

ON THE SERVER:
edit:
we can do this like the client does. Only networking-related stuff written in C++. Everything else, including  asynchronous i/o callbacks, is going to be handled in lua. 
Consider one global "master" lua_State eg. for current globals (server settings for example) and commands from developer console.
Then we could have one lua_State per every worker thread.
Then on any i/o callback, globals from "master" lua_State would be copied to the thread-specific lua_State.

Advantages of this approach are as follows:
- faster and easier workflow
- creating NPCs, items and whatnot during server runtime without the need to reboot

Disadvantages:
- a bit worse performance (but we shouldn't worry now; we'll later seek bottlenecks and reimplement them in C++)

OLD approach:
(((( 
All the logic written in C++ for the sake of easy threading and performance. 
Scripting only for server startup: initialization stuff for entities, maps etc. written in lua (we'll use Tiled maps exported to lua by the way). 
Consider scripted AI (but not necessarily).
))))

ON THE CLIENT: Separation of concerns: again - C++ for iocp + networking stuff, eg. my own-rolled reliable udp protocol, all the send/recv and other utility functions.
How is it going to work: C++ will hold two queues: one for outcoming and one for incoming messages.



 (worker iocp thread, mainly transferring and acknowledging messages), 
whereas Lua code will simply interpret all the incoming messages.
There is going to be a queue for incoming messages and outcoming messages, both protected by a critical section that lua code will occassionally step into.


Perhaps all the networking stuff will be written in C++;
Lua will be only used for initialization stuff (not only map loading; also new client initialization etc.) 
and should not be included in realtime logic because it can't be efficiently multithreaded.


When the packet with a new position arrives to the server, 
it should calculate a force vector (or velocity vector) to be applied to the character so that in the next simulation step it reaches the requested position.

Regarding dynamic objects:

Inside client simulation, other characters can not at all collide with dynamic objects - only the player can, so it compensates for round trip time.
Whenever the server detects that a body has left the "sleeping" state, it updates positions for all the players, until they come to sleep again.



The server should simulate physics in some decent intervals, say 60/120 Hz, and there should be another thread that sends all UDP packets with the current game frame at a constant pace.


Firstly, we should create a simple connection over TCP/IP, as it will be definitely easier just to use tcp + iocp than to reimplement a reliable protocol over UDP that acts AS GOOD as TCP.
Anyway it will be of use to gain that knowledge.

THEN AGAIN, I am more biased towards using UDP only. 
We will have a lot less overhead and the volume of our data will be really really low and TCP optimizes for amount of data sent per fixed amount of time, where with UDP we can optimize
for latency.

THIS IS ALSO BECAUSE: HERE, USING TCP FOR CHAT MESSAGES/LEVEL DATA IS A PREMATURE OPTIMIZATION.
I will anyway need a reliable layer on top of UDP for gunshots, since they have to be sent with a higher frequency and that is something I cannot control with TCP.
When it turns out that we need more flow control over level data or reliable commands, we'll use TCP for each of these accordingly. Period.



Then we are going to make use of some simple UDP class that merely makes non-blocking calls to recv and send.
NOPE! We are going to use UDP within IOCP, too. At least we'll have all the multithreading in one place.

What is important for now is to create a suitable workplace that will enable us to work on both the client and the server.

Please, try to grasp one concept at a time.

--------------------------------------------------------------------------------------------------
GAMEPLAY
--------------------------------------------------------------------------------------------------

Feature: scrolling.
Player should be able to instantly zoom in and out by using scroll. 
This will function as a map; it will greatly help in navigation and make the player situationally aware.


--------------------------------------------
BULLETS
--------------------------------------------

Implement the penetration as follows: assign an initial damage to the bullet, then
on BeginContact/EndContact play particle effects, and on every PreSolve disable the contact and decrease the damage by some arbitrary, density value.
If the bullet's damage becomes less than zero, delete the bullet.


About server-client synchronization:
Assuming the environment is static, things are very simple. 
The server simply broadcasts the message that the bullet was fired. 
If the bullet lands on a player or another interactive object - simply if it causes an important even to happen (death, for example) - broadcast this fact.
If it hits the wall, we don't care about broadcasting this information since if the environment is static the clients will simulate things the same way.

Things become problematic when we consider dynamic objects - the question arises, who decides about the lifetime of the bullet on the client?
If the client, it is very responsive, we have less bandwidth, but we may falsely simulate a hit against a moving crate, while the bullet actually just flew past it and actually hit the player, for example.
If the server, the hits become less responsive and the bandwidth is doubled, but the hits are always correctly shown only where they occur.

Or, a mix of both: how about sending info only when the bullet hits a dynamic object, and on the client never check against collisions with dynamic objects?
+ still responsive against static terrain;
+ it's better to falsely show a bullet passing through the client-driven character than a false hit against a crate standing in front of us when the bullet actually hit us;
- a little more bandwidth; it's far from being doubled, though.

For the client-driven bullets, do the opposite - check collisions with dynamic objects and only ever receive events caused by the bullet.

Summarizing:

Client-side:
- local bullet hits a static object
- local bullet hits a dynamic object
- remote bullet hits a static object

Client gets info about events in which:
- remote bullet hits a dynamic object
- local bullet makes an event (hits the player)
- remote bullet makes an event (hits the player)


What if we do the hit-detection client-side?
Now if we send a "I hit that player!" message to the server, the server goes back in time resimulates bullet+static environment and only checks whether such a bullet landed on such a player.

We will need to reliably measure the lag between the server and the client to properly advance the bullet forward in time on the server;
without the possibility of cheating.


Note that when receiving "new_bullet" notification, we may want to move it forward in time on the client, by the amount of lag.


RIGHT NOW - worry only about the experience. We'll think about the security implications only when we'll achieve the best possible implementation regarding client's experience/lag perception.

Basically, there are things that will look different across the clients according to their individual ping times - especially objects' positions.
But there are also events whose visual impact can be very well synchronized across all the clients upon the arrival of course - bullets for example, won't change their trajectory and even if it is the client
that is authoritative about the bullet's lifetime, we may succeed in showing the bullet position consistently across all the clients, regardless of differing pings.


Security implications regarding penetration of dynamic objects:
Locally, every time client's bullet hits a dynamic object (be it a crate), it sends an according notification to the server "i'm inside that crate" with the step number,
so the server can immediately broadcast the fact of hitting the crate to the clients

Eventually, the client will hit the player and tell the server so;
now if during the resimulation the server sees that the bullet DID hit the crate, it checks if an according message was earlier sent by the client.
If not, we have a liar or a poor connection. If yes, the server decreases the damage of the bullet and continues simulation check.





The synchronization_system should in fact be named "replication_system".
We should keep a library of item objects and their creation callbacks with an option to differ between client-side and server-side objects.
Then just send an object id type and information about synchronized modules, or just specify these modules in the archetype itself, or have both options available.



For the case where the client gets deleted because of death and his bullets still exists - consider a client as another entity with its own synchronization id, and its physical body another entity.
On client death, only the physical body gets deleted, the client still exists and thus the ownership of bullets is retained.
Then only ever delete the client when all of its bullets are freed.

When predicting remote bullets on the client, they might get deleted before the hit notification arrives.

We have several options here:
a) for remote bullets, don't delete bullets on collision and keep track of some amount of past weapon.existing_bullets
b) send all the impact data along with the hit information
c) simply delete the bullet only if it still exists and if it doesn't, make up some default impact data.

we'll probably do a mix od b) and c)


As for the conception of dying and throwing a corpse, we have to consider still-existing bullets shot by the deleted entity.
The solution is simple: treat bullets as independent objects and when the SHOT_INFO arrives to the client, save any metadata about the sender (e.g. nick) in the bullet entity.

-----------------------------------------------------------------------------------------
DESIGNING THE REPLICATION SYSTEM
-----------------------------------------------------------------------------------------
 
Problem: Data like pos/vel/orientation will need to be updated in batches, specifying the data layout ONLY ONCE to save per-packet bandwidth.
Solution: a dedicated STREAM_UPDATE message and sync_modules with reliable state.

Data like health points will be updated less frequently, so things like health updates can have their own message ids and layouts, 
although we only need to care about delivering the most recent state.

Given that the most recently received event associated with an object compensates for every previous event of this type,
the full object state can be reproduced using only the set of the most recently occurred events 
and an objects' initial values, what in turn is estabilished between the server and the client even before the transmission begins.

Some updates will be as simple as transferring the fact of changing a value (health points) 
but sometimes we will need to transfer RESULTS of one's actions, for example positions or velocities doesn't just mean overwriting some values - on the client, we'll need to interpolate.


We will also need objects whose state can't be reproduced using only set of the last events. 
Consider an object that depicts a set of squad points drawn by the leader, where possible changes include removing or adding a point.

It becomes obvious we'll need some kind of delta comparision between the last sent state and the current state.

We don't need delta for things like health.









Consider the following: 
Let the sync_modules just implement these methods:

write_state
write_stream
write_recent

read_state
read_stream
read_recent

the separation is necessary because of differing transportation methodology (reliable/sequenced/unreliable), 
but also because of differing data layouts:

[MODULESET_INFO][OBJECT_COUNT]...[id][STATE_MODULES_BITSET][STREAM_MODULES_BITSET]	...
[STATE_UPDATE]  [OBJECT_COUNT]...[id][modules_changed][write_state] 			  	...[id][modules_changed][write_state] ...
[RECENT_UPDATE] [OBJECT_COUNT]...[id][modules_changed][write_recent]				...[id][modules_changed][write_recent]...
[STREAM_UPDATE] [OBJECT_COUNT]...[id][write_stream]									...[id][write_stream]...


Explanation:
MODULESET_INFO (in-order, reliable):
This "could" be just named "NEW_OBJECTS", as it is to induce object creation on the remote peer.
This may also change the modules attached to an existing object and thus change STREAM_UPDATE data layout.

STATE_UPDATE (in-order, reliable): 
For state that can't be reproduced by just sending the last change and needs to be delta encoded, for example: 
a set of items in inventory or a set of squad waypoints drafted by the squad leader.

RECENT_UPDATE (reliable sequenced):
For state that can be reproduced by just sending the last change, for example: health points, controlled object id.

STREAM_UPDATE (reliable sequenced if acking every update; otherwise (optimal): unreliable but acknowledged on demand):
For state that is constantly sent per almost every object, 
and thus it's too costly to send data layout on every update - in fact, we need to specify it only when it changes - for example,
a player stops moving and does not need its pos/vel transmitted, yet they still move their crosshairs.
So the layout in output bitstream changes from [id][pos][vel][orient] ---> [id][orient]

Once the reliable_channel.lua detects that a [reliable sequenced message] for a given sync_module has been acknowledged,
it will issue a notification (MODULESET_INFO) that the STREAM_MODULES_BITSET has changed.

Here it will be best to create separate mappings for streaming-only modules and state-only modules.



in fact, state updates will be rare.
most updates will be transferred in a sequenced reliable manner.

IMPLEMENTATION:
Firstly, make sync_modules simply components. They can still be accessed object-wise.

We also need to remember that if an object is synchronized differently across multiple clients (client.alternative_modules)
then upon updating a module, we need to ensure that all objects variants are respectively updated, too.

Firstly, make delta-encoding for RECENT_UPDATE only module-wise. 
This means the whole module is updated when something changes inside.

When needed, we'll also implement field-wise delta.

We still don't have any use-case for STATE_UPDATE other than creating entities and transferring moduleset bitfield.



Later optimizations:

optimized STREAM_UPDATE:
[STREAM_UPDATE][OBJECT_ID_SET]...[write_stream]...[write_stream]...[write_stream]...

-----------------------------------------------------
VARIOUS RELIABILITY OPTIONS
-----------------------------------------------------

what we have available:
- per-message reliable in-order delivery
- per-message reliable sequenced delivery
- appended unreliable messages that we don't care about acknowledging




------------------------------------------------------------------------------------------
REPLICATION SYSTEM - FINAL PLAN
------------------------------------------------------------------------------------------



Look: Every object that contains only PODs (let it even be vec2's) can ALWAYS be replicated by just sending the last recent state (or "change").
These objects should not contain vectors of objects.

For example, every item in inventory should have its own ID, as well as every squad waypoint. 
This of course assumes that we have enough IDs for all of our objects.
Every magazine for the gun. Just let all of these simply hold its owner ID.

If we need something like transmitting EVERY health change, e.g. for the sake of correctly displaying damage-numbers,
we simply add a new transient event to the protocol and still synchronize the health by STATE_UPDATE.

So we don't need to separate the concepts of STATE_UPDATE and RECENT_UPDATE. Let's only have STATE_UPDATE (which is, in fact, RECENT_UPDATE).

for every sync_module, we'll have multiple reliable sequencing channels:
one is: sync_module_STREAM, as this is of sufficient granularity
and we'll have one sequencing channel per module field.

Consider merging the concepts of STATE_UPDATE and STREAM_UPDATE. 

Consider having an independent copy of modulesets per synchronized object inside every client object.
This way we can control synchronization options individually per-client.

Let's now merge the concepts of state_update and stream_update and optimize later.


Assume there is a game object on the server that the players share.
3 commands come at once that change the game object's state. Now comes the update phase.
We iterate through clients, get their Area of Interest (let's now assume it is the whole world),
create new objects, destroy the ones that went outside AoI, 
then loop through their modules and see if the game object they are referring to has changed relevantly.

First make difference-updates module-wise. Only then switch to checking for change in individual fields if bandwidth becomes too high.



If an object does not change at all, don't iterate through all remote states for the client for performance.



We could take a way different approach by just having a moduleset instance per GROUP per object (and not per-object-per-client).
We could simply derive update rules from these groups and hold no internal space per client. That could possibly mean reliable in-order updates, but think about it.



Best solution: Just create a single object instance per group, then replicate the object ONCE per group, and choose which replica to send to the client.
Then in every group just check once which values have changed. Concatenate dirty flags these with found in remote_states table.
The client then should only hold network-specific data like which modules (and fields) were already acknowledged, and not full object instances.


If we introduce AoI, for the above to work we HAVE to assume that the object going outside AoI gets deleted on the client.


Assign different type-id to a player-controlled character and different type-id to a remotely controlled character and let the server resolve the difference.


What if an object existed for such a short period of time that we had both NEW_OBJECTS and DELETE_OBJECTS in a single update?
What if we had reliable message stream like NEW_OBJECTS|SHOT_INFO|DELETE_OBJECT ? We should have an update separator.

We'll read in-order reliable updates loop-by-loop, whereas the most recent state will be read only when there are no loops left.
We should think about what to send by STATE_UPDATE and what to use reliable in-order delivery for.


What if SHOT_INFO with id=X is posted before posting NEW_OBJECTS with id=X?
For a case like this we would make "object-dependent events" - if an object is outside of client's AoI and we still get an event that needs the object's existence on the client,
we would compose a stream like this: [NEW_OBJECTS][EVENT][DELETE_OBJECTS], whereas the object would:
a) be created using a dedicated module_set.
b) be created using a standard PUBLIC module_set.

Redesign the way reliable messages are posted. (especially these existential)


Note we don't have to force the server to preserve proper reliable message ordering - loop separators are enough and the client will handle given types of messages
in a correct order since client-side loop is designed this way.

To cope with object-dependent events we can simply create a table like client.one_time_AoI and when the event occurs, simply push the dependency's id there. 
The table is then cleared in synchronization_system on every client's update.
Note that to correctly reproduce the event we might need to reliably send the initial object state to the client, so an option to reliably send STATE_UPDATE's would be handy.
Or even better, differentiate between reliable replica modules/fields. There's also this consideration if the object should be in another group if its outside of clients proximity. Perhaps.


To cope with a [SHOT_INFO][NEW_OBJECTS][DELETE_OBJECTS] case, we can only ever delete pending entities when an update tick is called. 
And then, send these delete events within the same loop separator.
The thing is to always request a valid existent ids from synchronization_system:update_object_states

If we call all systems, and thus generate events and post them reliably only during update pass, we are ensured that the server ticks are fully reproduced on the client.
We would still handle incoming packets every loop but at the moment only post them as generic "game_messages" with timestamps.
This could work better or worse under low tickrate conditions (especially considering physics),
but maybe we only have to assure that the delete events are to be handled and posted only every update pass.
Potential problem: if we then proceed to simulate the whole world with a higher tickrate, an object that was requested by the logic to be deleted might still exist for a several ticks and influence the logic.

To handle transferring reliable in-order value changes (as we would need in case of controlled_object_id inside client_info)
we could insert state updates in-between reliable messages.


ABOUT INIT-ONLY RELIABLE DATA AND RELIABLE COMMANDS IN/OUT OF PROXIMITY:
Simple. Whenever a reliable event that occurs for a replicable object and that events possibly changes its initial-only reliable state, 
iterate through its remote_state table and send the message to all clients that remote_state is non-nil for. 

If an event is dependent on the object and should be transmitted even outside of the basic proximity, 
we should replicate the object and post it BEFORE applying the changes.
Or just make it not dependent on the changes THAT THIS EVENT TRIGGERS (is it enough?).

And really, don't bother with writing a system that tries to reliably broadcast all variable changes on object field basis;
just stick to hand-written messages because most of the time, they will anyway trigger more actions than just "changing the value"
so you will anyway need to hand-write another message structure.

Don't forget to remotely delete already out-of-proximity objects inside object state update function inside replication system.



------------------------------------------------------------------------------------------
ITEM SYSTEM
------------------------------------------------------------------------------------------

In fact, what the server sends to the clients is merely:
- the results of actions
- data that can be used to "unpack" or "simulate" the actions relying on the current state,
which means reliably in-order sent state, especially not current STATE_UPDATEs (which, in fact, are the said results themselves).

Thus, before the commands for the item are transmitted, item state needs to be reliably synchronized, especially the fact of picking it up.


Target behaviour:

Server-side, all items are properly simulated - that is, every dropped/wielded item contains the same instance of all information about this item.
Client-side, only the items wielded by the subject are fully replicated, all others are only synchronized in terms of their appearance.

Still, we need to synchronize "some" data about the items, for example to know how to simulate remote shot messages.

So what we know for sure is this: dropped, unactive items don't need their item data synchronized.

We need to separate archetype-constant parameters (like maybe weapon spread and bullet velocity) and changeable parameters like current rounds left.

Method:

Client-side, create dropped items according to the entity archetype + server modules. No item data.
Have "wield" component for all characters. Remote commands that are to be "resimulated" will run without constraints like current_rounds > 0 check


Consider this:

1. dropped items with only PUBLIC moduleset
2. wielded items with PUBLIC, OWNER, (SQUAD) modulesets

Current rounds need to be synchronized only once (when weapon is picked up).



New idea:

Items are always the same entities, regardless of being dropped/picked.

When the item is wielded:
The client that owns the item maps the item's id (client.group_by_id) to OWNER group.
The other clients map to PUBLIC group.

When the item is dropped:
All clients map to single PUBLIC group for the dropped item.

When the item is being picked up:
We "replace" PUBLIC group with OWNER group and transmit initial data for the OWNER group.


The character object depends on its wielded entity (if any) which means the wielded item is replicated beforehand.

The character object will have a module with only reliable-initial-state synchronized 
and whenever it changes clients will be notified by DROP_ITEM/PICK_ITEM reliable messages.


Later if it turns out that the item systems need such a mechanism, we'll implement reliable in-order variable changes.
But for now it all can be done with custom messages so let's first at least prove that we need such a feature.


We might need to synchronize weapon state (shooting_interval, ready, etc.) as init data.



Remember to do the character ownership similiar way as item ownership, that is, by passing events to systems which in turn 
update group_by_id tables etc.






